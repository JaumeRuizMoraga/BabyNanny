package babbynannyapi.controller;

import babbynannyapi.model.*;
import babbynannyapi.repository.*;
import org.json.JSONException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;


@RestController
@RequestMapping("/BabyNanny")
public class Controlador {

	@Autowired
	private UserRepository userRepository;

	@Autowired
	private TokenRepository tokenRepository;

	@Autowired
	private BabyRepository babyRepository;

    @Autowired
    private IntakeRecordRepository intakeRecordRepository;

    @Autowired
    private SleepRecordRepository sleepRecordRepository;

    @Autowired
    private MedicalRecordRepository medicalRecordRepository;


	@GetMapping("/babies")
	ResponseEntity<Object> searchBabies(@RequestParam(name = "token") String token){
		Optional<Token> t = tokenRepository.searchToken(token);
		if (t.isPresent()) {
			List<Baby> babyList = babyRepository.searchBabies(t.get().getUser());
		    Map<String, List<Baby>> response = new HashMap<>();
		    response.put("babies", babyList);
			return ResponseEntity.status(HttpStatus.OK).body(response);
		}
		return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
	}
	
	@GetMapping("/getUser")
	ResponseEntity<Object> searchUser(@RequestParam(name = "token") String token){
		Optional<Token> t = tokenRepository.searchToken(token);
		if (t.isPresent()) {
			Optional<User> user = userRepository.findByName(t.get().getUser());
			return ResponseEntity.status(HttpStatus.OK).body(user);
		}
		return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
	}
	
	@DeleteMapping("/deleteBaby/{id}")
    public ResponseEntity<Void> deleteBaby(@PathVariable String id, @RequestHeader String token) {
		Optional<Token> t = tokenRepository.searchToken(token);
		if(t.isPresent()){
			Optional<Baby> optionalBaby = babyRepository.findById(id);
			Baby baby = optionalBaby.get();
			deleteBabyFromUser(baby);
			babyRepository.deleteById(id);
	        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
		}
		else {
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
		}
    }
	
	public void deleteBabyFromUser(Baby baby) {
		List<String> userList = baby.getTutors();
		for(String s : userList) {
			Optional<User> optionalUser = userRepository.findByName(s);
			User user = optionalUser.get();
			List<String> babyList = user.getBabies();
			babyList.remove(baby.getId());
			user.setBabies(babyList);
			userRepository.save(user);
		}
    }
	
	@DeleteMapping("/logOut/{id}")
    public ResponseEntity<Void> logOut(@PathVariable String id) {
		Optional<Token> t = tokenRepository.findById(id);
		if(t.isPresent()){
			tokenRepository.deleteById(id);
	        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
		}
		else {
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
		}
    }


	@PutMapping("/newEntry/{id}")
	ResponseEntity<Object> newEntry(@PathVariable String id, @RequestHeader String token, @RequestBody Map<String, Object> obj) throws JSONException {
		Optional<Token> t = tokenRepository.searchToken(token);

		if (t.isPresent()) {
			Optional<Baby> b = babyRepository.findById(id);
            List<String> babyList;

            if (b.isPresent()) {
                String type = (String) obj.get("type");

                switch (type) {
                    case "intakeRecord" : {
                        IntakeRecord irecord = new IntakeRecord();
                        irecord.setDate(new Date());
                        irecord.setIntakeAmount(Double.parseDouble(obj.get("amount").toString()));
                        intakeRecordRepository.save(irecord);
                        babyList= b.get().getIntakeRecord();
                        babyList.add(irecord.getId());
                        b.get().setIntakeRecord(babyList);
                        babyRepository.save(b.get());
                        return ResponseEntity.status(HttpStatus.OK).build();

                    }
                    case "medicalRecord" : {
                        MedicalRecord mrecord = new MedicalRecord();
                        Recipe recipe = new Recipe();
                        recipe.setDosisTime(Integer.parseInt(obj.get("dosisTime").toString()));
                        recipe.setDosis(Double.parseDouble(obj.get("dosis").toString()));
                        recipe.setMedicine(obj.get("medicine").toString());
                        mrecord.setDate(new Date());
                        mrecord.setRecipe(recipe);
                        medicalRecordRepository.save(mrecord);
                        babyList= b.get().getMedicalRecord();
                        babyList.add(mrecord.getId());
                        b.get().setMedicalRecord(babyList);
                        babyRepository.save(b.get());
                        return ResponseEntity.status(HttpStatus.OK).build();
                    }
                    case "sleepRecord" : {
                        SleepRecord srecord = new SleepRecord();
                        srecord.setDate(new Date());
                        srecord.setTimeSleep(Double.parseDouble(obj.get("timeSleep").toString()));
                        sleepRecordRepository.save(srecord);
                        babyList= b.get().getSleepRecord();
                        babyList.add(srecord.getId());
                        b.get().setSleepRecord(babyList);
                        babyRepository.save(b.get());
                        return ResponseEntity.status(HttpStatus.OK).build();
                    }
                }
            }
			return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
		}
		return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
	}
	
	/**
     * Creates a new token in the database with the information provided in the request body.
     * @param user. The user object containing the registration details.
     * @return a {@code ResponseEntity} with HTTP 200 OK if the baby is created successfully, 
     * or HTTP 401 Unauthorized if the user don't have a correct token.
     */
	
    @PostMapping("/login")
    public ResponseEntity<Object> login(@RequestBody User user){
        Optional<User> userObj = userRepository.findByNameAndPassword(user.getName(), user.getPassword());
        Optional<Token> userToken = tokenRepository.searchUserToken(user.getName());
        if (userObj.isPresent()) {
            if (userToken.isPresent()) {
                return ResponseEntity.status(HttpStatus.OK).body(userToken.get());
            } else {
                Token token = new Token(user.getName());
                tokenRepository.save(token);
                return ResponseEntity.status(HttpStatus.OK).body(token);
            }
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
    }
    
    
    /**
     * Creates a new baby in the database with the information provided in the request body.
     * @param baby. The baby object containing the baby information.
     * @param token. A identification for the user.
     * @return a {@code ResponseEntity} with HTTP 200 OK if the baby is created successfully, 
     * or HTTP 401 Unauthorized if the user don't have a correct token.
     */
    @PostMapping("/newBaby")
    public ResponseEntity<Object> newBaby(@RequestBody Baby baby, @RequestHeader String token){
    	Optional<Token> t = tokenRepository.searchToken(token);

    	if (t.isPresent()) {
            babyRepository.save(baby);
            List<String> babyList;
            Optional<User> user = userRepository.findByName(t.get().getUser());
            babyList = user.get().getBabies();
            babyList.add(baby.getId());
            user.get().setBabies(babyList);
            userRepository.save(user.get());
            return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
    }

    /**
     * Creates a new user in the database with the information provided in the request body.
     * @param user. The user object containing the registration details.
     * @return a {@code ResponseEntity} with HTTP 200 OK if the user is created successfully, 
     * or HTTP 403 Forbidden if the user already exists.
     */
    @PostMapping("/register")
    ResponseEntity<?> register(@RequestBody User user) {
        Optional<User> userPassEmail = userRepository.searchUserPassEmail(user.getName(), user.getPassword(), user.getEmail());
        if (userPassEmail.isPresent()) {
            return ResponseEntity.status(HttpStatus.CONFLICT).build();
        }
        else {
        		userRepository.save(user);
        		Token token = new Token(user.getName());
                tokenRepository.save(token);
                return ResponseEntity.status(HttpStatus.OK).body(token);
        	}
        }
    }